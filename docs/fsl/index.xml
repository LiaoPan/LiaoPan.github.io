<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>FSL系列教程 on 脑技术计划</title>
    <link>https://LiaoPan.github.io/fsl/</link>
    <description>Recent content in FSL系列教程 on 脑技术计划</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 05 Jan 2023 23:05:15 +0800</lastBuildDate><atom:link href="https://LiaoPan.github.io/fsl/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>FSL系列教程 #1.FSL安装</title>
      <link>https://LiaoPan.github.io/fsl/installation/</link>
      <pubDate>Wed, 01 Feb 2023 19:00:48 +0800</pubDate>
      
      <guid>https://LiaoPan.github.io/fsl/installation/</guid>
      <description>安装方法简述 安装校验 在MATLAB上使用FSL Flanker公开数据下载 通过fsleyes查看结构像数据 通过fsleyes查看功能像数据 参考 安装方法简述 访问网址,填写信息，下载对应版本的软件； 跟着教程指导，安装FSL软件。 打开终端命令行，使用管理员权限运行下述脚本 cd ~/Your_Downloads_DIR sudo python fslinstaller.py 注意: 1. 你的电脑上得有python的运行环境，不然无法执行下述python脚本。 2. 有网络，可以方便脚本自动从网络上下载相关软件包。
安装校验 打开终端命令行，执行下述脚本:
$ echo $FSLDIR # 校验环境变量 $ flirt -version # 校验软件是否正常使用，成功会输出:FLIRT version 6.0,版本号会有差异。 $ which imcp # 校验miniconda environment installation /usr/local/fsl/share/fsl/bin/imcp 通过在终端命令行输入fsl,可打开UI界面；
通过类似&amp;lt;fsl命令&amp;gt;_gui方式，可以打开UI界面。比如Bet_gui,注意fsl命令的首字母需要大写。
在MATLAB上使用FSL 在 macOS 上，fslinstaller 脚本通常会为您进行设置，因此您不需要这样做。但是，如果安装程序由于某种原因无法配置 MATLAB，您可能需要手动执行此操作。
MATLAB % FSL Setup setenv( &amp;#39;FSLDIR&amp;#39;, &amp;#39;/usr/local/fsl&amp;#39; ); setenv(&amp;#39;FSLOUTPUTTYPE&amp;#39;, &amp;#39;NIFTI_GZ&amp;#39;); fsldir = getenv(&amp;#39;FSLDIR&amp;#39;); fsldirmpath = sprintf(&amp;#39;%s/etc/matlab&amp;#39;,fsldir); path(path, fsldirmpath); clear fsldir fsldirmpath; Flanker公开数据下载 访问Openeuro官网，下载Flanker task的fMRI数据集。 下载的ds000102数据集使用的是Flanker任务，其目的是为了挖掘一种被称为认知控制的心理过程。在本教程中，我们将把认知控制定义为为了正确完成任务而忽略不相关的刺激的能力。</description>
    </item>
    
    <item>
      <title>FSL系列教程 #2. 预处理</title>
      <link>https://LiaoPan.github.io/fsl/preprocess/</link>
      <pubDate>Mon, 19 Jun 2023 17:06:21 +0800</pubDate>
      
      <guid>https://LiaoPan.github.io/fsl/preprocess/</guid>
      <description>简介 步骤一： Brain Extraction(颅骨去除，skullstripping) 步骤一：如何使用bet命令行的方式去除颅骨 如何修复效果差的颅骨去除 步骤二：基于FEAT的预处理(汇总) 运动校正（Motion Correction） 时间层校正，Slice-Timing Correction 平滑，Smoothing 配准和归一化： 仿射变换（Affine Transformations） 配准与归一化（Registration and Normalization） 预处理检查 检查配准与归一化 检查运动伪迹 参考 许多示例都是从Flanker/sub-08目录运行的,所以推荐使用sub-08数据进行分析计算。
简介 对fMRI数据进行预处理时发现，一个fMRI volume不仅包含我们感兴趣的信号&amp;ndash;含氧血液的变化，还包含我们不感兴趣的波动，如头部运动（head motion）、随机漂移(random drifts)、呼吸(breathing)和心跳(heartbeats)。我们把这些其他波动称为噪声，因为我们想把它们与我们感兴趣的信号分开。其中一些可以通过建模从数据中回归出来，另一些可以通过预处理减少或去除。
接下来，我们开始对sub-08’s的数据进行预处理。
步骤一： Brain Extraction(颅骨去除，skullstripping) 由于fMRI研究的重点是大脑组织，我们的第一步是将头骨和非大脑区域从图像中移除。FSL有一个名为bet的工具，即大脑提取工具。它是FSL图形用户界面上列出的第一个按钮（BET brain extraction,在下图中用 &amp;ldquo;A &amp;ldquo;表示）。如果你点击这个按钮，就会打开另一个窗口，允许你指定输入图像来进行头骨剥离，以及对已进行头骨剥离的输出图像进行标注（B），还有一个可扩展的子窗口，允许你指定高级选项（C）。
对于BET和许多其他FSL工具，你需要指定一个输入图像和一个输出图像的标签： 在输入图像上进行一些操作（例如头骨剥离），输出图像是该操作的结果。通常情况下，其他选项被设置为默认值，对大多数数据集都很有效，但如果你想的话，你可以覆盖它们。
从sub-08目录下打开FSL GUI(比如，进入该目录后，打开终端，输入fsl命令，启动FSL GUI)，点击输入图像栏旁边的文件夹图标，并导航到anat目录。选择文件sub-08_T1w.nii.gz并点击确定按钮。请注意，输出图像字段是自动填写的，在你的输入图像上附加了大脑这个词，这是FSL的默认值。如果你愿意，你可以改变这个名字，但在本教程中我们将保持原样。
现在点击窗口底部的 &amp;ldquo;Go&amp;quot;按钮。你会看到一些文本被写入你的终端，显示哪些命令被用来运行一个叫做bet2的命令。花点时间看看GUI是如何与终端对应的&amp;ndash;稍后我们将利用这一点，通过GUI创建一个模板，然后在终端中对其进行修改，以自动预处理我们数据集中的所有对象。
当终端显示 &amp;ldquo;Finished &amp;ldquo;时，bet2就完成了。由于你已经创建了一个新的图像，我们应该看一下数据。在之后的每个预处理步骤之后，都建议看一下处理完成的数据，检查一下数据被处理后的质量。
sub-08被试的结构像数据展示 sub-08被试的结构像数据被去除颅骨后的展示 sub-08被试的结构像数据叠加去除颅骨后的数据（红黄色）展示 BET整体操作录屏 示范如何使用BET来检查剥离头骨前后的解剖图像。 点击GUI底部的FSLeyes按钮。当它打开时，点击FILE -&amp;gt; Add from File，并按住shift键选择原始的解剖图像和你刚刚创建的头骨去除图像。正如你在前一章中所看到的，你要改变对比度以清楚地区分灰质和白质。
通过加载这两幅图像，你可以比较头骨被移除之前和之后的图像。在FSLeyes左下角的叠加列表面板中，点击 &amp;ldquo;眼睛&amp;quot;图标来隐藏相应的图像。例如，如果你点击sub-08_T1w旁边的眼睛图标，原来的T1解剖图像将变得不可见，而你将只看到被头骨剥离的大脑。如果你再次点击眼睛，你将看到原始的T1。为了使大脑之间的差异更加明显，在叠加列表面板中突出显示头骨剥离的图像，然后将对比度从灰度改为蓝光蓝（或者其他想要呈现的颜色）。上面的动画告诉你如何做到这一点。
在2019年11月发布的fsleyes中，一些用户在试图加载由任何FSL命令生成的图像时，会遇到以下错误信息： &amp;ldquo;Error loading overlay: Does not look like a BIDS file.</description>
    </item>
    
    <item>
      <title>FSL系列教程 #3. 统计与建模 </title>
      <link>https://LiaoPan.github.io/fsl/statistics_analysis/</link>
      <pubDate>Mon, 03 Jul 2023 10:42:46 +0800</pubDate>
      
      <guid>https://LiaoPan.github.io/fsl/statistics_analysis/</guid>
      <description>简介 第一级分析(First Level Analysis) 1.时间序列(Time-Series) 2.BOLD（血氧水平依赖，Blood Oxygen Level Dependent）信号发展历史 3.血流动力学反应函数(HRF,Hemodynamic Response Function) 4.广义线性模型(General Linear Model) 5.创建Timing Files 6.第一级分析(First-Level Analysis)操作实践 第二级分析，2nd-Level Analysis 第三级分析，3nd-Level Analysis 参考资料 简介 现在，经过预处理后，我们可以对数据进行模型拟合。为了理解模型拟合的原理，我们需要回顾一些基本原理，如一般线性模型（GLM）、BOLD反应和什么是时间序列。这些主题在下面章节中都有讨论。
在你回顾了这些概念之后，你就可以使用FEAT进行一级分析了。下图说明了我们将如何对数据进行模型拟合。
在构建了一个表明BOLD反应应该是什么样子的模型（A）后，该模型被拟合到每个体素的时间序列上（B）。模型的拟合程度（也称为拟合度）可以用统计图在大脑上表示出来，强度越高表示模型拟合度越高。然后，这些统计图可以被阈值化，只显示具有统计学意义的模型拟合的体素（C）。 第一级分析(First Level Analysis) 1.时间序列(Time-Series) 为了理解模型拟合的工作原理，首先我们需要回顾一下fMRI数据的构成。请记住，fMRI数据集包含几个volumes，像串珠子一样串在一起&amp;ndash;我们把这串volumes的串联称为数据run。在整个run过程中，在每个体素测量的信号被称为时间序列。
在SPM中，一个run被称为一个session。有些术语在不同的分析包中没有标准化。在本课程中将继续使用上述run的定义。
为了说明这看起来像什么，打开fsleyes浏览器，加载数据集filtered_func_data.nii.gz。在右下角有一个标记为 &amp;ldquo;Location&amp;quot;的窗口，有一个名为 &amp;ldquo;Volume&amp;quot;的字段。这表明在观察窗口中显示的时间序列的当前volume。点击该字段旁边的向上箭头，显示时间序列中的下一卷，注意从一卷到下一卷有微小但明显的变化。
要看到时间序列以更快的速度连续更新，请点击电影卷轴模样的图标&amp;quot;Movie Reel&amp;quot;。可以通过点击扳手图标(&amp;ldquo;Wrench&amp;rdquo;)来改变更新速度。
然后，点击屏幕上方的View菜单，选择时间序列（Time series）。这就打开了另一个窗口，显示整个时间序列的信号变化，X轴上是volume序号。y轴是扫描仪以任意单位来衡量采集的fMRI信号；在对每个扫描进行归一化处理后，我们可以解释这些单位，并在不同条件下比较归一化信号。
时间序列代表了在每个体素上测量的信号，但这个信号来自哪里？在下一节，我们将简要回顾fMRI的历史，以及我们如何产生你在viewer中看到的信号。
2.BOLD（血氧水平依赖，Blood Oxygen Level Dependent）信号发展历史 在整个20世纪80年代和90年代初，神经影像学研究人员将使用正电子发射断层扫描（PET）等方法测量大脑组织之间的对比度。这涉及到注射一种放射性的葡萄糖示踪剂(radioactive glucose tracer)，当神经元发射时被其吸收。通过在不同的实验条件下拍摄大脑图像，如看到一个闪烁的棋盘或做一个认知要求高的问题，研究人员可以看到哪些区域与其他区域相比更活跃。
然而，这种方法是侵入性的，而且被注射放射性示踪剂的想法使许多人不敢成为这种实验的对象。到20世纪90年代初，一种被称为磁共振成像（MRI）的替代成像技术已经变得更快、更便宜，研究人员正在寻找一种方法，使其更广泛地用于临床。1990年，贝尔实验室的一位名叫Seiji Ogawa的研究人员发现，更多的脱氧血液会导致从一个大脑区域测得的信号减少。而另一方面，含氧血液的增加会增加信号&amp;ndash;这种含氧血液的增加后来被证明与神经发射的增加相关联。这种信号的变化被称为血氧水平依赖信号（或BOLD信号）。
此后不久，在1992年，马萨诸塞州总医院(Massachusetts General Hospital)一位名叫Ken Kwong的研究人员证明，BOLD信号可被用作神经活动的间接测量。他的实验包括向受试者交替显示一个闪烁的棋盘和一个黑屏，每次一分钟。在每个条件下都记录了BOLD信号，如以下视频所示： 这个是一个重要的实验，成为许多功能神经成像实验的模板。Kwong找到了一种方法，利用体内的血液作为内源性示踪剂，对健康受试者的大脑活动进行成像，消除了对注射或辐射的需要。因此，fMRI实验变得更加流行，到2000年代初，fMRI已成为主流的神经影像学方法。
BOLD信号作为神经发射的间接测量方法 尽管Ogawa和Kwong的发现对使用MRI的神经成像者来说是一个福音，但也有一个问题：这种新方法是对大脑活动的间接测量，与实际的神经发射相差了几步。每当有刺激出现时&amp;ndash;如闪光或突然的噪音&amp;ndash;该刺激被感觉器官转化为神经冲动，反过来刺激大脑中的神经元发射。发射的神经元需要氧气，而氧气是由血液输送的。这种含氧的血液反过来又增加了来自附近的氢气在你体内的信号，这就是扫描仪中所测量的。
尽管如此，这也是用来推断大脑某一区域是否 &amp;ldquo;活跃 &amp;ldquo;的措施。而要做出这些推断，我们将需要仔细研究BOLD信号、实验设计，以及我们如何将两者与数学模型结合起来。
3.血流动力学反应函数(HRF,Hemodynamic Response Function) 从BOLD反应到HRF 在上一小节中，我们读到了关于BOLD信号代表什么的一些假设；我们的另一个假设是BOLD反应是什么样子。这不仅对建立神经活动和血流之间的联系、从那里到观察信号的建模很重要，而且对我们如何定义一个模型来测试哪些脑区对给定刺激的BOLD反应有明显变化也很重要。
在20世纪90年代，对BOLD信号的实证研究表明，在向受试者呈现一个刺激后，大脑的任何部分对该刺激有反应&amp;ndash;例如，视觉皮层对一个视觉刺激的反应&amp;ndash;显示出BOLD信号的增加。BOLD信号似乎也遵循一个一致的形状，在6秒左右达到峰值，然后在接下来的几秒钟内回落到基线。这种形状可以用一个叫做伽马分布（Gamma Distribution）的数学函数来模拟。当伽马分布被创建为最适合大多数经验研究观察到的BOLD反应的参数时，我们把它称为典型的血液动力学反应函数，或HRF。
当应用于fMRI数据时，伽马分布被称为基础函数(baiss function)。我们称它为基础函数，因为它是我们将创建的模型的基本元素，或基础，并适合于数据的时间序列。此外，如果我们知道分布的形状在应对非常短暂的刺激时是什么样的，我们就可以预测它在应对不同持续时间的刺激时应该是什么样的，以及任何随时间呈现的刺激组合。现在我们来看看每种情况的说明。</description>
    </item>
    
    <item>
      <title>FSL系列教程 #4. ROI分析 </title>
      <link>https://LiaoPan.github.io/fsl/roi_analysis/</link>
      <pubDate>Thu, 06 Jul 2023 15:29:51 +0800</pubDate>
      
      <guid>https://LiaoPan.github.io/fsl/roi_analysis/</guid>
      <description>简介 使用脑图谱 使用结构像掩膜抽取数据 使用球体抽取数据 练习实践 简介 我们刚刚完成了一个组分析，并确定了大脑的哪些区域在实验的不一致（&amp;ldquo;Incongruent&amp;rdquo;）和一致（&amp;ldquo;congruent&amp;rdquo;）条件下显示出明显的差异。对于一些研究人员来说，这可能是他们想要做的全部。
这种分析被称为全脑(whole-brain)或探索性分析(exploratory)。当实验者对差异的位置没有假设时，这些类型的分析很有用；这个结果将作为未来研究的基础。
然而，当对一个特定的被试进行了大量的研究后，我们可以开始对我们应该在大脑图像中找到的结果做出更具体的假设。例如，认知控制已经被研究了很多年，许多关于它的fMRI研究已经发表，使用不同的范式，将认知要求较高的任务与认知要求较低的任务进行比较。通常情况下，在认知要求高的条件下，BOLD信号的明显增加出现在大脑的一个区域，即背内侧前额叶皮层（dosal medial prefrontal cortex），或简称为dmPFC。那么，对于Flanker研究，我们可以将我们的分析限制在这个区域，只从该区域的体素中提取数据。这就是所谓的兴趣区域（ROI,region of interest）分析。在看全脑结果之前，选择分析一个选定的区域，这种分析的一般名称叫做确认性分析(confirmatory analysis)。
全脑图(Whole-brain maps)可以隐藏我们正在研究的效果的重要细节。我们可能会发现incongruent-congruent的显着效应，但效应显着的原因可能是incongruent大于congruent，或者是incongruent比congruent的消极得多，或者是两者的某种组合。确定是什么在驱动这种效应的唯一方法是ROI分析，这在处理交互作用和更复杂的设计时尤其重要。
使用脑图谱 为我们的ROI分析创建一个区域(region)的方法是使用图谱(atlas)，或将大脑划分为解剖学上的不同区域的地图。
FSL已经安装了许多图谱(atlas)，我们可以通过FSL viwer访问这些图谱。如果点击 &amp;ldquo;Settings&amp;rdquo;-&amp;gt;&amp;ldquo;Ortho View 1&amp;rdquo;-&amp;gt;&amp;ldquo;Atlas Panel&amp;rdquo;，就会打开一个名为Atlases的新窗口。默认情况下，将加载哈佛-牛津大学皮质和皮质下图谱（Harvard-Oxford Cortical and Subcortical Atlases）。我们可以通过点击图谱名称旁边的Show/Hide链接看到图集是如何分割大脑的。观察窗口中十字线中心的体素将被分配一个属于大脑结构的概率。
哈佛-牛津大学皮质图谱，显示在MNI模板大脑上。图谱窗口显示体素位于某个解剖区域的概率。 要将这些区域之一保存为提取数据的文件，也称为掩膜(mask)，点击想用作mask的区域旁边的Show/Hide链接&amp;ndash;在我们的例子中，假设我们想用副扣带回(Paracingulate Gyrus)作为mask。点击该链接将显示该区域叠加在大脑上，并在 &amp;ldquo;Overlay list&amp;quot;叠加列表窗口中将其加载为叠加。点击图像旁边的磁盘图标，将其保存为一个mask。把它保存到Flanker目录下，称为PCG.nii。
我们的结果将具有与我们用于归一化的模板相同的分辨率。FSL中默认的是MNI_152_T1_2mm_brain，它的分辨率为2x2x2mm。当我们创建一个mask时，它的分辨率将与它所覆盖的模板相同。当我们从mask中提取数据时，数据和mask需要有相同的分辨率。为了避免因图像分辨率不同而导致的任何错误，请使用与我们用于归一化数据的相同模板来创建mask。
使用结构像掩膜抽取数据 一旦创建了掩膜，我们就可以从中提取每个受试者的对比度估计值（contrast estimates）。虽然你可能认为我们会提取第三级分析的结果，但实际上我们想要的是第二级分析的结果；第三级分析是一个单一的图像，每个体素都有一个数字，而在ROI分析中，我们的目标是单独提取每个受试者的对比度估计。
以Incongruent-Congruent对比度估计为例，我们可以在Flanker_2ndLevel.gfeat/cope3.feat/stats目录下找到每个受试者的数据图(data maps)。这些数据图有几种不同的计算方式，包括t统计图、cope图和方差图。我更倾向于从z-统计图中提取数据，因为这些数据已经被转换为正态分布的形式，在我看来，更容易绘制和解释。
为了使我们的ROI分析更容易，我们将把所有的z-统计图合并成一个数据集。为了做到这一点，我们将使用FSL命令和Unix命令的组合。导航到Flanker_2ndLevel.gfeat/cope3.feat/stats目录，然后输入以下内容：
fslmerge -t allZstats.nii.gz `ls zstat* | sort -V` 这将沿着时间维度（用-t选项指定）把所有的Z-statistic图像合并成一个数据集；这只是意味着把各volume数据串联起来，成为一个更大的数据集。第一个参数是输出数据集的名称（allZstats.nii.gz），后面的代码使用星号通配符列出每个以 &amp;ldquo;zstat&amp;quot;开头的文件，然后用-V选项从小到大对它们进行数字排序。
将allZstats.nii.gz文件上移三层，使其位于Flanker主目录中（即输入mv allZstats.nii.gz .../../...）。然后使用fslmeants命令从PCG掩码中提取数据：
fslmeants -i allZstats.nii.gz -m PCG.nii.gz 这将打印26个数字，每个被试一个。每个数字是该被试的对比度估计值，是mask中所有体素的平均数。 这个命令输出的每个数字都对应于进入分析的对比度估计值。例如，第一个数字对应的是sub-01的Incongruent-Congruent的平均对比度估计值，第二个数字是sub-02的平均对比度估计值，以此类推。这些数字可以复制并粘贴到你选择的统计软件包（如R）中，然后你可以对它们进行t检验。 使用球体抽取数据 我们可能已经注意到，使用解剖学掩膜的ROI分析结果并不显著。这可能是因为PCG掩膜覆盖了一个非常大的区域；虽然PCG被标记为一个单一的解剖区域，但我们可能是从几个不同的功能区域提取数据。因此，这可能不是最好的ROI方法。
另一种技术被称为球形ROI方法（spherical ROI）。在这种情况下，一个给定直径的球体以指定的X、Y和Z坐标的三组为中心。这些坐标通常是基于另一项研究的峰值激活，该研究使用与我们所使用的相同或相似的实验设计。这被认为是一个独立的分析，因为ROI的定义是基于一个单独的研究。
下面的动画显示了解剖学和球形ROI的区别： 为了创建这个ROI，我们需要从另一项研究中找到峰值坐标；让我们随机挑选一篇论文，如Jahn等人，2016。在结果部分，我们发现Stroop任务存在冲突效应&amp;ndash;这是一个不同但相关的实验设计，也是为了挖掘认知控制&amp;ndash;在MNI坐标0、20、40处有一个峰值t统计。
接下来的几个步骤很复杂，所以要密切注意每一个步骤：
打开fsleyes，并加载一个MNI模板。在Location窗口的&amp;quot;Coordinates:MNI152&amp;quot;&amp;ldquo;下的字段中，输入0 20 44。就在这些字段的右边，注意体素位置下的字段中的数字的相应变化。在这种情况下，它们是45 73 58。写下这些数字。</description>
    </item>
    
    <item>
      <title>FSL系列教程 #5. FSL脚本编写</title>
      <link>https://LiaoPan.github.io/fsl/scripts/</link>
      <pubDate>Mon, 03 Jul 2023 10:56:47 +0800</pubDate>
      
      <guid>https://LiaoPan.github.io/fsl/scripts/</guid>
      <description>简介 在对单个受试者的单次run进行预处理并建立模型之后，我们就需要对数据集中所有受试者的所有run进行相同的处理。这看似繁琐，但也是可行的&amp;ndash;我们只有26个受试者，每个受试者有两次run。我们可能认为这可以在一周左右的时间内完成；而且也可以随时将这项任务分配给几名研究助理。
然而，在某些时候，您会遇到两个问题：
我们会发现，手动分析每次运行不仅乏味，而且容易出错，随着要分析的运行数量增加，出错的概率也会显著增加； 对于较大的数据集（例如，80个受试者，每个受试者有5次run），这种方法很快就会变得不切实际。 另一种方法是编写分析脚本。就像演员有一个脚本，告诉他说什么、站在哪里、在哪里移动一样，我们也可以编写一个脚本，告诉计算机如何分析数据集。这样做有双重好处，既可以实现分析自动化，又可以分析任何规模的数据集&amp;ndash;分析两个受试者或两百个受试者的代码几乎完全相同。
首先，我们将创建一个模板，其中包含分析单次run所需的代码，然后我们将使用for-loop自动分析所有运行。这个想法很简单；尽管代码一开始可能难以理解，但一旦我们对其更加熟悉，我们就会发现如何将其应用于任何数据集。
理解下述代码脚本需要Linux的shell脚本基础，推荐掌握了基础的shell脚本语法后，再来继续阅读下述内容。
创建脚本模版 当分析sub-08被试的第一个run时，会创建一个名为run1.feat的目录。在该目录下有几个文件和子目录。其中一个文件design.fsf包含了从FEAT图形用户界面转录到文本文件中的所有代码。这是FSL运行来完成每个预处理和建模步骤的代码。如果在文本编辑器中打开design.fsff文件和用来创建design.fsf文件的FEAT图形用户界面并排比较，我们可以看到输入到FEAT图形用户界面的数据在哪里被写入design.fsf文件。
如果我们打开了FEAT图形用户界面，点击屏幕底部的Load按钮，并选择run1.feat目录下的design.fsf文件，它将把所有设置更改为您保存脚本时在图形用户界面中输入的设置。
在前面的教程中，我们分别运行了FEAT的预处理和模型拟合。现在我们将从FEAT GUI的下拉菜单中选择 &amp;ldquo;Full Analysis（全分析）&amp;quot;，创建一个将这两个步骤结合在一起的模板。
首先，输入rm -r run1.feat删除当前run1.feat目录。然后在命令行输入Feat_gui打开FEAT图形用户界面。我们将在下拉菜单中选择 &amp;ldquo;Full Analysis（全面分析）&amp;ldquo;选项，而不是将其作为两个单独的会话来运行。以前面的教程为指导，填写预处理和模型拟合的所有必填项。
填写完所有字段后，不要点击Go按钮，而是点击Save并标注文件为design_run1。这将保存多个扩展名为 &amp;ldquo;con&amp;rdquo;、&amp;ldquo;mat &amp;ldquo;和 &amp;ldquo;png &amp;ldquo;的文件，但我们的脚本将使用文件design_run1.fsf。
现在对run 2执行相同的步骤，加载相应的功能数据和时序文件。将文件保存为design_run2.fsf。
在代码编辑器(或者文本编辑器)中打开design_run1.fsf，查看所有已填写的选项。我们的目标是使该模板可用于任何被试，只需在for-loop中稍作改动即可。在本例中，我们唯一需要更改的是被试名称，其余选项对每个被试都是相同的。
运行脚本 将design_run1.fsf和design_run2.fsf文件移到包含被试的目录下（即mv design*.fsf ..，然后cd ..）。然后下载脚本 run_1stLevel_Analysis.sh(如下述代码所示)，并将其移动到Flanker目录中：
run_1stLevel_Analysis.sh #!/bin/bash # Generate the subject list to make modifying this script # to run just a subset of subjects easier. # 依次遍历26个被试数据 for id in `seq -w 1 26` ; do subj=&amp;#34;sub-$id&amp;#34; echo &amp;#34;===&amp;gt; Starting processing of $subj&amp;#34; echo cd $subj # 颅骨去除 # If the brain mask doesn’t exist, create it if [ !</description>
    </item>
    
  </channel>
</rss>
