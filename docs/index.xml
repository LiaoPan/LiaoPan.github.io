<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>主页 on 脑技术计划</title>
    <link>https://LiaoPan.github.io/</link>
    <description>Recent content in 主页 on 脑技术计划</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 05 Jan 2023 23:05:15 +0800</lastBuildDate><atom:link href="https://LiaoPan.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>AFNI 系列教程 #1.Preprocessing</title>
      <link>https://LiaoPan.github.io/afni/preprocess/</link>
      <pubDate>Thu, 08 Jun 2023 18:23:06 +0800</pubDate>
      
      <guid>https://LiaoPan.github.io/afni/preprocess/</guid>
      <description>简介 预处理步骤 1. AFNI命令与uber_subjects.py 运行Uber被试脚本：a. 配置分析脚本 运行Uber被试脚本：b. 运行分析脚本 2. 时间层校正(Slice-Timing Correction) 3. 配准与归一化(Registration and Normalization) 4. 对齐与运动校正(Alignment and Motion Correction) 5. 平滑(Smoothing) 6. 掩膜(or 掩码)与缩放(Masking and Scaling) 7. 检查预处理结果 参考 简介 我们在对fMRI数据进行预处理时，会对每个TR获取的三维图像进行清理。一个fMRI容积(volume)不仅包含我们感兴趣的信号&amp;ndash;含氧血液的变化，还包含我们不感兴趣的波动(fluctuations)，如头部运动(head motion)、随机漂移(random drifts)、呼吸(breathing)和心跳(heartbeats)。我们将这些波动称为噪声(noises)，因为我们希望将它们从我们感兴趣的信号中分离出来。其中一些可以通过建模从数据中回归出来（将在建模拟合一章中讨论），其他的可以通过预处理减少或去除。
数据前提：请提前准备好Flanker task数据集，我们可以在OpenNeuro网站上找到并免费下载。
要开始预处理sub-08的数据，请通读以下章节。我们将首先概述如何使用AFNI命令，然后介绍uber_subject.py，它允许编写一个脚本，为我们完成所有预处理。然后，您将了解为什么要进行这些预处理步骤，以及如何在每个步骤之前和之后检查数据质量。
预处理步骤 不同的软件包会以略微不同的顺序完成这些步骤&amp;ndash;例如，FSL会在模型拟合后对统计图(statistical map)进行归一化处理。还有一些分析省略了某些步骤&amp;ndash;例如，一些做多体素模式分析（multi-voxel pattern analyses）的人不平滑他们的数据。无论如何，下面列出的是在典型数据集上执行的最常见步骤。
1. AFNI命令与uber_subjects.py 简介
在所有fMRI分析软件包中，AFNI有最难学的名声。尽管过去可能确实如此，但AFNI的开发人员在过去几年中努力使他们的软件更易学易用：除了查看器，AFNI的最新版本还包含其他图形用户界面，可以通过命令uber_subject.py和uber_ttest.py访问这些图形界面。这些图形用户界面用于创建脚本，自动完成每个被试的预处理和模型设置。
在讨论这些命令之前，我们先回顾一下典型AFNI命令的基本原理。毕竟，&amp;ldquo;uber&amp;quot;脚本只是将大量命令按照处理数据的顺序编译在一起。您还将使用单个AFNI命令执行更高级的分析，如感兴趣区域（ROI）分析。
AFNI 命令
AFNI命令类似于Unix命令： 它们通常需要至少一个参数或输入，而且通常还需要指定命令输出的名称。
以头骨剥离为例，这是一个常见的预处理步骤，用于将头骨从大脑中剥离出来。执行这一步的AFNI命令称为3dSkullStrip。导航至sub-08/anat目录，然后输入3dSkullStrip并按回车键，我们可以看到该命令的帮助文档信息。
通常情况下，只键入命令而不输入任何参数将默认打印帮助文档。在这里我们需要指定一个额外的标志-h来打印帮助文件，输入3dSkullStrip -h然后按回车键。你会注意到屏幕上打印了大量的文本，超过了终端可以同时显示的数量。如果想看更容易阅读的帮助文件，键入3dSkullStrip -h | less。竖条表示竖条左边命令的输出，即&amp;quot;3dSkullStrip -h&amp;rdquo;，应该被导入less命令，它允许你上下翻阅帮助文件。在这个 &amp;ldquo;分页窗口&amp;quot;中，输入&amp;quot;d&amp;quot;可以向下翻一页，输入&amp;quot;u&amp;quot;可以向上翻一页，输入上下箭头可以上下翻一行。要搜索帮助文件，键入一个正斜线（/），然后键入要查找的文本，按回车键。要退出分页窗口，请按 &amp;ldquo;q&amp;quot;键。
**文档和帮助文件是AFNI的最大优势。每条命令的用法都有清晰的概述，并详细解释了使用不同选项的原因。**给出的示例命令涵盖了不同的情况&amp;ndash;例如，如果颅骨去除后在输出图像中留下了太多的颅骨，我们建议使用-push_to_edge这样的选项。
3dSkullStrip最基本的用法是使用-input标志来指定将要被剥离的解剖数据集。例如
3dSkullStrip -input sub-08_T1w.nii.gz 大约一分钟后，会生成一个名为skull_strip_out+orig的新文件。这就是头骨切片的解剖图像，我们可以打开AFNI浏览器查看。你可能会注意到在额叶有几个体素的皮质被移除，头骨顶部和后部有一些硬脑膜残留，但总体来说头骨剥离的效果非常好。
另一种查看条纹质量的方法是加载原始解剖图像sub-08_T1w.nii.gz作为Underlay，加载颅骨去除图像skull_strip_out作为Overlay。我们可以通过点击观察窗口中的任意位置，然后按 &amp;ldquo;o&amp;quot;键来交替查看和隐藏叠加；另一个选项是按 &amp;ldquo;u&amp;quot;键来在每张图像之间切换。这些查看选项将有助于您在预处理步骤前后检查数据。</description>
    </item>
    
    <item>
      <title>FSL系列教程 #1.FSL安装</title>
      <link>https://LiaoPan.github.io/fsl/installation/</link>
      <pubDate>Wed, 01 Feb 2023 19:00:48 +0800</pubDate>
      
      <guid>https://LiaoPan.github.io/fsl/installation/</guid>
      <description>安装方法简述 安装校验 在MATLAB上使用FSL Flanker公开数据下载 通过fsleyes查看结构像数据 通过fsleyes查看功能像数据 参考 安装方法简述 访问网址,填写信息，下载对应版本的软件； 跟着教程指导，安装FSL软件。 打开终端命令行，使用管理员权限运行下述脚本 cd ~/Your_Downloads_DIR sudo python fslinstaller.py 注意: 1. 你的电脑上得有python的运行环境，不然无法执行下述python脚本。 2. 有网络，可以方便脚本自动从网络上下载相关软件包。
安装校验 打开终端命令行，执行下述脚本:
$ echo $FSLDIR # 校验环境变量 $ flirt -version # 校验软件是否正常使用，成功会输出:FLIRT version 6.0,版本号会有差异。 $ which imcp # 校验miniconda environment installation /usr/local/fsl/share/fsl/bin/imcp 通过在终端命令行输入fsl,可打开UI界面；
通过类似&amp;lt;fsl命令&amp;gt;_gui方式，可以打开UI界面。比如Bet_gui,注意fsl命令的首字母需要大写。
在MATLAB上使用FSL 在 macOS 上，fslinstaller 脚本通常会为您进行设置，因此您不需要这样做。但是，如果安装程序由于某种原因无法配置 MATLAB，您可能需要手动执行此操作。
MATLAB % FSL Setup setenv( &amp;#39;FSLDIR&amp;#39;, &amp;#39;/usr/local/fsl&amp;#39; ); setenv(&amp;#39;FSLOUTPUTTYPE&amp;#39;, &amp;#39;NIFTI_GZ&amp;#39;); fsldir = getenv(&amp;#39;FSLDIR&amp;#39;); fsldirmpath = sprintf(&amp;#39;%s/etc/matlab&amp;#39;,fsldir); path(path, fsldirmpath); clear fsldir fsldirmpath; Flanker公开数据下载 访问Openeuro官网，下载Flanker task的fMRI数据集。 下载的ds000102数据集使用的是Flanker任务，其目的是为了挖掘一种被称为认知控制的心理过程。在本教程中，我们将把认知控制定义为为了正确完成任务而忽略不相关的刺激的能力。</description>
    </item>
    
    <item>
      <title>快速入门</title>
      <link>https://LiaoPan.github.io/dipy/basic/</link>
      <pubDate>Tue, 10 Jan 2023 14:30:41 +0800</pubDate>
      
      <guid>https://LiaoPan.github.io/dipy/basic/</guid>
      <description>快速入门 本教程知识点：
导入和保存dMRI的NIfTI数据 绘制与查看dMRI影像数据 读取bval和bvec文件 Jupyter已省略部分内容，请点击这里全屏显示 </description>
    </item>
    
    <item>
      <title>FreeSurfer教程 #1. 安装</title>
      <link>https://LiaoPan.github.io/freesurfer/installation/</link>
      <pubDate>Sun, 08 Jan 2023 22:09:43 +0800</pubDate>
      
      <guid>https://LiaoPan.github.io/freesurfer/installation/</guid>
      <description>安装方法简述 根据自己系统下载对应的安装包（FreeSurfer 7.3.2 ~5G） 通过网址( https://surfer.nmr.mgh.harvard.edu/registration.html ),获取license.txt,将其放置在FreeSurfer的安装目录下(比如/Applications/freesurfer/7.3.2)。 依次执行下述脚本，设置环境变量,注意freesurfer的版本7.3.2需要替换成自己安装的版本。 shell $ export FREESURFER_HOME=/Applications/freesurfer/7.3.2 $ export SUBJECTS_DIR=$FREESURFER_HOME/subjects $ source $FREESURFER_HOME/SetUpFreeSurfer.sh -------- freesurfer-darwin-macOS-7.3.2-20200429-3a03ebd -------- Setting up environment for FreeSurfer/FS-FAST (and FSL) WARNING: /Users/synpro/freesurfer/fsfast does not exist FREESURFER_HOME /Applications/freesurfer/7.3.2 FSFAST_HOME /Users/synpro/freesurfer/fsfast FSF_OUTPUT_FORMAT nii.gz SUBJECTS_DIR /Applications/freesurfer/7.3.2/subjects MNI_DIR /Users/synpro/freesurfer/mni $ which freeview /Applications/freesurfer/7.3.2/bin/freeview 注意上述方式时临时有效，即仅对当前打开的终端有效，关闭该终端后，上述设置都会失效。
永久设置环境变量方法： 将上述脚本写入~/.bash_profile文件中,操作命令如下： shell $ vi ~/.bash_profile #打开该文本，写入内容(若不熟悉vim，请使用其他工具打开即可); # FREESURFER export FREESURFER_HOME=/Applications/freesurfer/7.3.2 export SUBJECTS_DIR=$FREESURFER_HOME/subjects source $FREESURFER_HOME/SetUpFreeSurfer.sh $ source .bash_profile # 让设置立即生效 需要注意的是，上面的设置默认使用bash，如果你在Mac上使用的是zsh等shell工具，需要再做如下配置，来达到环境变量设置的永久生效。
1.$ vim ~/.</description>
    </item>
    
    <item>
      <title>MRtrix3教程 #1 快速入门</title>
      <link>https://LiaoPan.github.io/mrtrix/basic/</link>
      <pubDate>Sat, 07 Jan 2023 01:44:51 +0800</pubDate>
      
      <guid>https://LiaoPan.github.io/mrtrix/basic/</guid>
      <description>相关知识点 基础概念 1. T1像与T2像 2. 白质的结构 3.扩散梯度（Diffusion Gradient）与B值（B-value） 4.B向量（B-vectors） 5.张量建模 6.其他的扩散衡量指标 7.扩散张量成像的缺点：交叉纤维问题 MRtrix Viewer使用 BTC_preop（Brain Tumor Connectomics Data）数据下载 MRtrix数据格式与格式转换 检查Bvals和Bvecs 学习参考 MRtrix是一个用于分析扩散数据的软件包。与张量拟合技术相比，MRtrix的一个显著优势是他们的约束球面反卷积方法，或称CSD(Constrained spherical deconvolution)；该方法将每个体素的扩散信号解卷为一系列重叠的纤维束,这就减少了在拟合张量时可能出现的纤维交叉问题。
除了MRtrix团队创建的命令库之外，该软件封装了FSL的部分命令：特别是topup和eddy这两个命令。如果你还没有安装FSL软件，请下载并安装fMRI软件包FSL。
相关知识点 学习使用fixel-based分析方法来量化每个体素的白质纤维密度 学习怎么使用概率纤维束成像创建纤维束图 学习如何创建连接体(connectomes)以及如何可视化连接不同大脑区域的纤维数量 基础概念 1. T1像与T2像 在T1或解剖扫描中，白质比灰质浅，而灰质又比脑脊液浅；在T2或功能扫描中，相对强度被翻转。 典型的T1加权（解剖）和 T2加权（功能）图像。注意从T1加权成像到T2加权成像时组织类型的相对强度是如何反转的。
然而，还有其他类型的图像可以通过MRI扫描仪获得。在本节中，我们将重点讨论扩散加权核磁共振成像，或称dMRI，它测量大脑不同部位的相对扩散性&amp;ndash;特别是在白质束内。
2. 白质的结构 为什么dMRI会关注白质束？想象一下剥开一根奶酪条，然后想象一下剥开大脑&amp;ndash;就像奶酪条一样，大脑有首选的撕裂方向。这些方向与底层白质束相对应，白质束是厚厚的有髓神经元束（myelinated neurons），连接着大脑的附近和遥远的部分。例如，下纵束(inferior longitudinal fasciculus)连接大脑的视觉和颞部区域，而钩束(uncinate fasciculus)则连接大脑的颞部和下额部。这些神经束沿着大脑的所有三个维度行进，它们可能相互平行或相互交叉。
Illustration of several main white matter tracts. Figure taken from Thiebaut et al., 2015. 大脑的白质因其颜色而得名；这些神经元是高度髓鞘化的，这意味着它们有一层厚厚的脂质涂层，既能使它们绝缘，又有助于电脉冲的传输，就像绝缘的电线。相比之下，灰质神经元则相对没有髓鞘，这使得特定区域内的神经元密度更高。
如果对Diffusion的历史感兴趣，详情请查看
3.扩散梯度（Diffusion Gradient）与B值（B-value） 扩散梯度由以下参数生成：
The magnitude of diffusion gradient (G); The time between gradients (𝚫) ; T duration of diffusion gradient (𝜹).</description>
    </item>
    
    <item>
      <title>AFNI 系列教程 #2.统计与建模</title>
      <link>https://LiaoPan.github.io/afni/stats/</link>
      <pubDate>Thu, 20 Jul 2023 18:57:54 +0800</pubDate>
      
      <guid>https://LiaoPan.github.io/afni/stats/</guid>
      <description>简介 运行一级分析（First-Level Analysis） uber_subject.py 脚本的再次使用 刺激时序文件（Stimulus Timing Files） 广义线性测试（Symbolic GLTs） 额外的回归选项(Extra Regress Options) 理想时间序列与广义线性模型 检查输出结果 查看统计文件 参考资料 简介 现在，经过预处理后，我们可以对数据进行模型拟合。为了理解模型拟合的原理，我们需要回顾一些基本原理，如一般线性模型（GLM）、BOLD反应和什么是时间序列。这些主题在下面章节中都有讨论。
在你回顾了这些概念之后，你就可以使用FEAT进行一级分析了。下图说明了我们将如何对数据进行模型拟合。
在构建了一个表明BOLD反应应该是什么样子的模型（A）后，该模型被拟合到每个体素的时间序列上（B）。模型的拟合程度（也称为拟合度）可以用统计图在大脑上表示出来，强度越高表示模型拟合度越高。然后，这些统计图可以被阈值化，只显示具有统计学意义的模型拟合的体素（C）。 关于时间序列、BOLD信号、HRF、广义线性模型相关基础知识，可参阅FSL教程。
运行一级分析（First-Level Analysis） uber_subject.py 脚本的再次使用 之前，我们使用uber_subject.py命令为单个研究对象设置了预处理脚本。你可能还记得，我们删除了其中一个名为&amp;quot;regress&amp;quot;的处理块，因为我们当时并不关注回归。但现在，我们将把回归块添加回uber_subject.py脚本中，并将预处理和一级分析合并到一个脚本中。
让我们为同一个被试sub-08创建一个新脚本。首先，导航到sub-08目录，输入rm -r subject_results，删除预处理目录。在包含所有被试的目录下，在命令行中输入uber_subject.py。这一次，在&amp;quot;analysis initialization&amp;quot;部分，我们将保留所有数据块的原样（不过，由于本示例数据集中的数据已经进行了切片时间校正，因此可以删除&amp;quot;tshift &amp;ldquo;数据块而不影响结果，这一点在前面的章节中已经讨论过）。
按照预处理的方法填写解剖和功能图像，并对 &amp;ldquo;extra align options&amp;quot;和 &amp;ldquo;extra tlrc options&amp;quot;进行同样的修改。本章我们将重点讨论图形用户界面的以下部分：
stimulus timing files; symbolic GLTs; extra regress options. 如果uber_subject.py不能使用，比如pyqt4老旧安装麻烦等问题，导致脚本不能使用，建议使用下述使用uber_subject.py脚本输出的sub_08_afni_proc.sh脚本。
sub_08_afni_proc.sh #!/usr/bin/env tcsh # created by uber_subject.py: version 1.2 (April 5, 2018) # creation date: Mon Nov 18 12:30:05 2019 # set subject and group identifiers set subj = sub_08 set gname = Flanker # set data directories set top_dir = ${PWD}/sub-08 set anat_dir = $top_dir/anat set epi_dir = $top_dir/func set stim_dir = $top_dir/func # run afni_proc.</description>
    </item>
    
    <item>
      <title>FSL系列教程 #2. 预处理</title>
      <link>https://LiaoPan.github.io/fsl/preprocess/</link>
      <pubDate>Mon, 19 Jun 2023 17:06:21 +0800</pubDate>
      
      <guid>https://LiaoPan.github.io/fsl/preprocess/</guid>
      <description>简介 步骤一： Brain Extraction(颅骨去除，skullstripping) 步骤一：如何使用bet命令行的方式去除颅骨 如何修复效果差的颅骨去除 步骤二：基于FEAT的预处理(汇总) 运动校正（Motion Correction） 时间层校正，Slice-Timing Correction 平滑，Smoothing 配准和归一化： 仿射变换（Affine Transformations） 配准与归一化（Registration and Normalization） 预处理检查 检查配准与归一化 检查运动伪迹 参考 许多示例都是从Flanker/sub-08目录运行的,所以推荐使用sub-08数据进行分析计算。
简介 对fMRI数据进行预处理时发现，一个fMRI volume不仅包含我们感兴趣的信号&amp;ndash;含氧血液的变化，还包含我们不感兴趣的波动，如头部运动（head motion）、随机漂移(random drifts)、呼吸(breathing)和心跳(heartbeats)。我们把这些其他波动称为噪声，因为我们想把它们与我们感兴趣的信号分开。其中一些可以通过建模从数据中回归出来，另一些可以通过预处理减少或去除。
接下来，我们开始对sub-08’s的数据进行预处理。
步骤一： Brain Extraction(颅骨去除，skullstripping) 由于fMRI研究的重点是大脑组织，我们的第一步是将头骨和非大脑区域从图像中移除。FSL有一个名为bet的工具，即大脑提取工具。它是FSL图形用户界面上列出的第一个按钮（BET brain extraction,在下图中用 &amp;ldquo;A &amp;ldquo;表示）。如果你点击这个按钮，就会打开另一个窗口，允许你指定输入图像来进行头骨剥离，以及对已进行头骨剥离的输出图像进行标注（B），还有一个可扩展的子窗口，允许你指定高级选项（C）。
对于BET和许多其他FSL工具，你需要指定一个输入图像和一个输出图像的标签： 在输入图像上进行一些操作（例如头骨剥离），输出图像是该操作的结果。通常情况下，其他选项被设置为默认值，对大多数数据集都很有效，但如果你想的话，你可以覆盖它们。
从sub-08目录下打开FSL GUI(比如，进入该目录后，打开终端，输入fsl命令，启动FSL GUI)，点击输入图像栏旁边的文件夹图标，并导航到anat目录。选择文件sub-08_T1w.nii.gz并点击确定按钮。请注意，输出图像字段是自动填写的，在你的输入图像上附加了大脑这个词，这是FSL的默认值。如果你愿意，你可以改变这个名字，但在本教程中我们将保持原样。
现在点击窗口底部的 &amp;ldquo;Go&amp;quot;按钮。你会看到一些文本被写入你的终端，显示哪些命令被用来运行一个叫做bet2的命令。花点时间看看GUI是如何与终端对应的&amp;ndash;稍后我们将利用这一点，通过GUI创建一个模板，然后在终端中对其进行修改，以自动预处理我们数据集中的所有对象。
当终端显示 &amp;ldquo;Finished &amp;ldquo;时，bet2就完成了。由于你已经创建了一个新的图像，我们应该看一下数据。在之后的每个预处理步骤之后，都建议看一下处理完成的数据，检查一下数据被处理后的质量。
sub-08被试的结构像数据展示 sub-08被试的结构像数据被去除颅骨后的展示 sub-08被试的结构像数据叠加去除颅骨后的数据（红黄色）展示 BET整体操作录屏 示范如何使用BET来检查剥离头骨前后的解剖图像。 点击GUI底部的FSLeyes按钮。当它打开时，点击FILE -&amp;gt; Add from File，并按住shift键选择原始的解剖图像和你刚刚创建的头骨去除图像。正如你在前一章中所看到的，你要改变对比度以清楚地区分灰质和白质。
通过加载这两幅图像，你可以比较头骨被移除之前和之后的图像。在FSLeyes左下角的叠加列表面板中，点击 &amp;ldquo;眼睛&amp;quot;图标来隐藏相应的图像。例如，如果你点击sub-08_T1w旁边的眼睛图标，原来的T1解剖图像将变得不可见，而你将只看到被头骨剥离的大脑。如果你再次点击眼睛，你将看到原始的T1。为了使大脑之间的差异更加明显，在叠加列表面板中突出显示头骨剥离的图像，然后将对比度从灰度改为蓝光蓝（或者其他想要呈现的颜色）。上面的动画告诉你如何做到这一点。
在2019年11月发布的fsleyes中，一些用户在试图加载由任何FSL命令生成的图像时，会遇到以下错误信息： &amp;ldquo;Error loading overlay: Does not look like a BIDS file.</description>
    </item>
    
    <item>
      <title>MRtrix3教程 #2 预处理</title>
      <link>https://LiaoPan.github.io/mrtrix/preprocessing/</link>
      <pubDate>Tue, 23 May 2023 11:05:36 +0800</pubDate>
      
      <guid>https://LiaoPan.github.io/mrtrix/preprocessing/</guid>
      <description>简介 dwi_denoise命令使用 mrcalc命令使用 mri_degibbs命令使用 提取反相编码图像(dwiextract、mrcat、mrmath) 将它们放在一起：使用dwipreproc进行预处理(Eddy处理，去除涡流) 检查损坏的切片 生成Mask(dwibiascorrect、dwi2mask) 参考资料 简介 就像其他神经影像学数据一样，扩散数据在分析前应进行预处理。预处理可以去除图像中的噪声源，如运动伪影和其他失真。扩散数据尤其容易受到相位编码方向的影响而产生扭曲的伪影： 一般来说，主要的编码方向&amp;ndash;如前向后(Anterior to Posterior, AP)&amp;ndash;会使大脑的前部看起来更 &amp;ldquo;压扁&amp;rdquo;，就像从前部方向吹来的强风。后至前(Posterior to Anterior,PA)，相位编码方向的情况则相反。有时这些扭曲是非常微妙的，但其他时候它们是明显的。 以下是使用 MRtrix 完成的常见预处理步骤:
dwi_denoise命令使用 我们要做的第一个预处理步骤是通过使用MRtrix的dwidenoise命令对数据进行去噪。这需要一个输入和一个输出参数，你也可以选择用-noise选项来输出噪声图。比如说：
# 查看使用说明 $ dwidenoise -h MRtrix 3.0.4 dwidenoise Dec 14 2022 dwidenoise: part of the MRtrix3 package SYNOPSIS dMRI noise level estimation and denoising using Marchenko-Pastur PCA USAGE dwidenoise [ options ] dwi out dwi the input diffusion-weighted image. out the output denoised DWI image. ...... # 运行此命令需要几分钟时间。 $ dwidenoise sub-CON02_ses-preop_acq-AP_dwi.</description>
    </item>
    
    <item>
      <title>纤维束追踪入门</title>
      <link>https://LiaoPan.github.io/dipy/tracking_basic/</link>
      <pubDate>Thu, 12 Jan 2023 16:20:45 +0800</pubDate>
      
      <guid>https://LiaoPan.github.io/dipy/tracking_basic/</guid>
      <description>Basic Tracking(Local fiber tracking) 本教程知识点：
如何使用扩散像数据集来实现纤维束重建 1)从扩散数据集获取方向(directions)的方法。 2)识别追踪何时必须停止的方法。 3)设置追踪种子(seed)。 如何保存trk文件 使用StatefulTractogram()和save_trk()函数保存trk文件 局部纤维跟踪(Local fiber tracking)是一种通过从局部方向信息创建流线(streamlines)来模拟白质纤维的方法。其思想如下:如果一个区域/路径段的局部方向是已知的，可以沿着这些方向进行集成，以构建该结构的完整表示。局部纤维束追踪因其简单、鲁棒性好而被广泛应用于扩散MRI领域。
步骤一. 从扩散数据集获取方向(directions)的方法
基于 Constant Solid Angle ODF模型来拟合数据，该模型会评估每个voxel的取向分布函数(ODF,Orientation Distribution Function)。OODF 是作为方向函数的水扩散分布。ODF的峰值是图像中某一点上束段(tract segments)方向的良好估计。在这里，我们使用peaks_from_model来拟合数据，并计算白质所有体素中的纤维方向。
步骤二. 识别追踪何时必须停止的方法
接下来，我们需要用某种方法将纤维追踪限制在具有良好方向性信息的区域。我们已经创建了白质掩码(white mask)，但我们可以更进一步，通过对广义分数各向异性（GFA,generalized fractional anisotropy）进行阈值处理，将纤维追踪限制在那些ODF显示出明显限制性扩散的区域。
步骤三. 设置追踪种子(seed)
在我们开始追踪之前，我们需要指定在哪里 &amp;ldquo;seed&amp;rdquo;（开始）纤维追踪。一般来说，选择的种子将取决于人们感兴趣的建模路径。在这个例子中，我们将在胼胝体的矢状切面上使用一个每个体素的2x2x2的网格种子。从这个区域进行追踪将给我们一个胼胝体束的模型。这个切片在标签的图像中具有标签值2。
使用EuDX算法构建一个确定性的纤维束流线(streamlines)。 所谓的确定性(deterministic)表示如果你重复纤维跟踪（保持所有输入相同），你将得到完全相同的一组纤维束流线。
Jupyter已省略部分内容，请点击这里全屏显示 使用csdeconv.mask_for_response_ssst()函数来获取每个体素的各向异性配置（very anisotropic configurations）的信息，该函数会返回所选体素的mask。 通过这个mask，我们就可以通过csdeconv.response_from_mask_ssst()函数计算响应函数。
load_nifti_data()和load_nifti()函数的区别:
load_nifti_data()只加载nifti内的data array。
load_nifti()除了加载data array,还要把其他信息也加载进来（data, img.affine, img, vox_size, nib.aff2axcodes(img.affine)）。
方向场（Direction Field）图如何看？
x - Red - 方向场图中为红色标识
y - Green - 方向场图中为绿色标识
z - Blue- 方向场图中为蓝色标识</description>
    </item>
    
    <item>
      <title>FreeSurfer教程 #2. FreeSurfer输出结果与FreeView可视化</title>
      <link>https://LiaoPan.github.io/freesurfer/basic/</link>
      <pubDate>Sun, 08 Jan 2023 21:19:31 +0800</pubDate>
      
      <guid>https://LiaoPan.github.io/freesurfer/basic/</guid>
      <description>0. 本文知识点汇总 1. 教程数据准备 FreeSurfer 的输出结果 使用FreeView来图片查看Volumes 使用FreeView来3D查看Surfaces 参考资料 0. 本文知识点汇总 FreeSurfer输出结果的简单理解 使用FreeView对FreeSurfer的结果（Volumes、Surfaces）进行可视化查看 1. 教程数据准备 在FsTutorial_Data下载相关教程的测试数据，大概8GB。
使用命令行下载相关教程数据，也可以直接访问网址下载，然后解压。
curl https://surfer.nmr.mgh.harvard.edu/pub/data/tutorial_data.tar.gz -o tutorial_data.tar.gz tar -xzvf tutorial_data.tar.gz rm tutorial_data.tar.gz export TUTORIAL_DATA=/path/to/your/tutorial/dir # 定义环境变量TUTORIAL_DATA ls $TUTORIAL_DATA buckner_data fsfast-functional diffusion_recons fsfast-tutorial.subjects diffusion_tutorial long-tutorial FreeSurfer 的输出结果 surf 文件夹下生成 . white、. sphere、. inflated 等网格点文件，每一个文件里面都存储了大脑皮质表面网格点的三维坐标及相邻顶点构成的三角面片信息。
surf 文件夹下生成基于曲面的形态特征数据，不同的特征采用不同的文件后缀名，
皮质厚度（ . thickness ） 雅可比度量（. jacobian. white） 脑沟（ . sulc ） 曲率（. curv） 外表面积（. area） 体积（. volume）等面数据文件，其坐标索引号与 Mesh 网格序号一致。 **stats **文件夹下，对于每个脑图谱(atlas)都有一个分区结果(parcellations)。比如，</description>
    </item>
    
    <item>
      <title>FSL系列教程 #3. 统计与建模 </title>
      <link>https://LiaoPan.github.io/fsl/statistics_analysis/</link>
      <pubDate>Mon, 03 Jul 2023 10:42:46 +0800</pubDate>
      
      <guid>https://LiaoPan.github.io/fsl/statistics_analysis/</guid>
      <description>简介 第一级分析(First Level Analysis) 1.时间序列(Time-Series) 2.BOLD（血氧水平依赖，Blood Oxygen Level Dependent）信号发展历史 3.血流动力学反应函数(HRF,Hemodynamic Response Function) 4.广义线性模型(General Linear Model) 5.创建Timing Files 6.第一级分析(First-Level Analysis)操作实践 第二级分析，2nd-Level Analysis 第三级分析，3nd-Level Analysis 参考资料 简介 现在，经过预处理后，我们可以对数据进行模型拟合。为了理解模型拟合的原理，我们需要回顾一些基本原理，如一般线性模型（GLM）、BOLD反应和什么是时间序列。这些主题在下面章节中都有讨论。
在你回顾了这些概念之后，你就可以使用FEAT进行一级分析了。下图说明了我们将如何对数据进行模型拟合。
在构建了一个表明BOLD反应应该是什么样子的模型（A）后，该模型被拟合到每个体素的时间序列上（B）。模型的拟合程度（也称为拟合度）可以用统计图在大脑上表示出来，强度越高表示模型拟合度越高。然后，这些统计图可以被阈值化，只显示具有统计学意义的模型拟合的体素（C）。 第一级分析(First Level Analysis) 1.时间序列(Time-Series) 为了理解模型拟合的工作原理，首先我们需要回顾一下fMRI数据的构成。请记住，fMRI数据集包含几个volumes，像串珠子一样串在一起&amp;ndash;我们把这串volumes的串联称为数据run。在整个run过程中，在每个体素测量的信号被称为时间序列。
在SPM中，一个run被称为一个session。有些术语在不同的分析包中没有标准化。在本课程中将继续使用上述run的定义。
为了说明这看起来像什么，打开fsleyes浏览器，加载数据集filtered_func_data.nii.gz。在右下角有一个标记为 &amp;ldquo;Location&amp;quot;的窗口，有一个名为 &amp;ldquo;Volume&amp;quot;的字段。这表明在观察窗口中显示的时间序列的当前volume。点击该字段旁边的向上箭头，显示时间序列中的下一卷，注意从一卷到下一卷有微小但明显的变化。
要看到时间序列以更快的速度连续更新，请点击电影卷轴模样的图标&amp;quot;Movie Reel&amp;quot;。可以通过点击扳手图标(&amp;ldquo;Wrench&amp;rdquo;)来改变更新速度。
然后，点击屏幕上方的View菜单，选择时间序列（Time series）。这就打开了另一个窗口，显示整个时间序列的信号变化，X轴上是volume序号。y轴是扫描仪以任意单位来衡量采集的fMRI信号；在对每个扫描进行归一化处理后，我们可以解释这些单位，并在不同条件下比较归一化信号。
时间序列代表了在每个体素上测量的信号，但这个信号来自哪里？在下一节，我们将简要回顾fMRI的历史，以及我们如何产生你在viewer中看到的信号。
2.BOLD（血氧水平依赖，Blood Oxygen Level Dependent）信号发展历史 在整个20世纪80年代和90年代初，神经影像学研究人员将使用正电子发射断层扫描（PET）等方法测量大脑组织之间的对比度。这涉及到注射一种放射性的葡萄糖示踪剂(radioactive glucose tracer)，当神经元发射时被其吸收。通过在不同的实验条件下拍摄大脑图像，如看到一个闪烁的棋盘或做一个认知要求高的问题，研究人员可以看到哪些区域与其他区域相比更活跃。
然而，这种方法是侵入性的，而且被注射放射性示踪剂的想法使许多人不敢成为这种实验的对象。到20世纪90年代初，一种被称为磁共振成像（MRI）的替代成像技术已经变得更快、更便宜，研究人员正在寻找一种方法，使其更广泛地用于临床。1990年，贝尔实验室的一位名叫Seiji Ogawa的研究人员发现，更多的脱氧血液会导致从一个大脑区域测得的信号减少。而另一方面，含氧血液的增加会增加信号&amp;ndash;这种含氧血液的增加后来被证明与神经发射的增加相关联。这种信号的变化被称为血氧水平依赖信号（或BOLD信号）。
此后不久，在1992年，马萨诸塞州总医院(Massachusetts General Hospital)一位名叫Ken Kwong的研究人员证明，BOLD信号可被用作神经活动的间接测量。他的实验包括向受试者交替显示一个闪烁的棋盘和一个黑屏，每次一分钟。在每个条件下都记录了BOLD信号，如以下视频所示： 这个是一个重要的实验，成为许多功能神经成像实验的模板。Kwong找到了一种方法，利用体内的血液作为内源性示踪剂，对健康受试者的大脑活动进行成像，消除了对注射或辐射的需要。因此，fMRI实验变得更加流行，到2000年代初，fMRI已成为主流的神经影像学方法。
BOLD信号作为神经发射的间接测量方法 尽管Ogawa和Kwong的发现对使用MRI的神经成像者来说是一个福音，但也有一个问题：这种新方法是对大脑活动的间接测量，与实际的神经发射相差了几步。每当有刺激出现时&amp;ndash;如闪光或突然的噪音&amp;ndash;该刺激被感觉器官转化为神经冲动，反过来刺激大脑中的神经元发射。发射的神经元需要氧气，而氧气是由血液输送的。这种含氧的血液反过来又增加了来自附近的氢气在你体内的信号，这就是扫描仪中所测量的。
尽管如此，这也是用来推断大脑某一区域是否 &amp;ldquo;活跃 &amp;ldquo;的措施。而要做出这些推断，我们将需要仔细研究BOLD信号、实验设计，以及我们如何将两者与数学模型结合起来。
3.血流动力学反应函数(HRF,Hemodynamic Response Function) 从BOLD反应到HRF 在上一小节中，我们读到了关于BOLD信号代表什么的一些假设；我们的另一个假设是BOLD反应是什么样子。这不仅对建立神经活动和血流之间的联系、从那里到观察信号的建模很重要，而且对我们如何定义一个模型来测试哪些脑区对给定刺激的BOLD反应有明显变化也很重要。
在20世纪90年代，对BOLD信号的实证研究表明，在向受试者呈现一个刺激后，大脑的任何部分对该刺激有反应&amp;ndash;例如，视觉皮层对一个视觉刺激的反应&amp;ndash;显示出BOLD信号的增加。BOLD信号似乎也遵循一个一致的形状，在6秒左右达到峰值，然后在接下来的几秒钟内回落到基线。这种形状可以用一个叫做伽马分布（Gamma Distribution）的数学函数来模拟。当伽马分布被创建为最适合大多数经验研究观察到的BOLD反应的参数时，我们把它称为典型的血液动力学反应函数，或HRF。
当应用于fMRI数据时，伽马分布被称为基础函数(baiss function)。我们称它为基础函数，因为它是我们将创建的模型的基本元素，或基础，并适合于数据的时间序列。此外，如果我们知道分布的形状在应对非常短暂的刺激时是什么样的，我们就可以预测它在应对不同持续时间的刺激时应该是什么样的，以及任何随时间呈现的刺激组合。现在我们来看看每种情况的说明。</description>
    </item>
    
    <item>
      <title>FSL系列教程 #4. ROI分析 </title>
      <link>https://LiaoPan.github.io/fsl/roi_analysis/</link>
      <pubDate>Thu, 06 Jul 2023 15:29:51 +0800</pubDate>
      
      <guid>https://LiaoPan.github.io/fsl/roi_analysis/</guid>
      <description>简介 使用脑图谱 使用结构像掩膜抽取数据 使用球体抽取数据 练习实践 简介 我们刚刚完成了一个组分析，并确定了大脑的哪些区域在实验的不一致（&amp;ldquo;Incongruent&amp;rdquo;）和一致（&amp;ldquo;congruent&amp;rdquo;）条件下显示出明显的差异。对于一些研究人员来说，这可能是他们想要做的全部。
这种分析被称为全脑(whole-brain)或探索性分析(exploratory)。当实验者对差异的位置没有假设时，这些类型的分析很有用；这个结果将作为未来研究的基础。
然而，当对一个特定的被试进行了大量的研究后，我们可以开始对我们应该在大脑图像中找到的结果做出更具体的假设。例如，认知控制已经被研究了很多年，许多关于它的fMRI研究已经发表，使用不同的范式，将认知要求较高的任务与认知要求较低的任务进行比较。通常情况下，在认知要求高的条件下，BOLD信号的明显增加出现在大脑的一个区域，即背内侧前额叶皮层（dosal medial prefrontal cortex），或简称为dmPFC。那么，对于Flanker研究，我们可以将我们的分析限制在这个区域，只从该区域的体素中提取数据。这就是所谓的兴趣区域（ROI,region of interest）分析。在看全脑结果之前，选择分析一个选定的区域，这种分析的一般名称叫做确认性分析(confirmatory analysis)。
全脑图(Whole-brain maps)可以隐藏我们正在研究的效果的重要细节。我们可能会发现incongruent-congruent的显着效应，但效应显着的原因可能是incongruent大于congruent，或者是incongruent比congruent的消极得多，或者是两者的某种组合。确定是什么在驱动这种效应的唯一方法是ROI分析，这在处理交互作用和更复杂的设计时尤其重要。
使用脑图谱 为我们的ROI分析创建一个区域(region)的方法是使用图谱(atlas)，或将大脑划分为解剖学上的不同区域的地图。
FSL已经安装了许多图谱(atlas)，我们可以通过FSL viwer访问这些图谱。如果点击 &amp;ldquo;Settings&amp;rdquo;-&amp;gt;&amp;ldquo;Ortho View 1&amp;rdquo;-&amp;gt;&amp;ldquo;Atlas Panel&amp;rdquo;，就会打开一个名为Atlases的新窗口。默认情况下，将加载哈佛-牛津大学皮质和皮质下图谱（Harvard-Oxford Cortical and Subcortical Atlases）。我们可以通过点击图谱名称旁边的Show/Hide链接看到图集是如何分割大脑的。观察窗口中十字线中心的体素将被分配一个属于大脑结构的概率。
哈佛-牛津大学皮质图谱，显示在MNI模板大脑上。图谱窗口显示体素位于某个解剖区域的概率。 要将这些区域之一保存为提取数据的文件，也称为掩膜(mask)，点击想用作mask的区域旁边的Show/Hide链接&amp;ndash;在我们的例子中，假设我们想用副扣带回(Paracingulate Gyrus)作为mask。点击该链接将显示该区域叠加在大脑上，并在 &amp;ldquo;Overlay list&amp;quot;叠加列表窗口中将其加载为叠加。点击图像旁边的磁盘图标，将其保存为一个mask。把它保存到Flanker目录下，称为PCG.nii。
我们的结果将具有与我们用于归一化的模板相同的分辨率。FSL中默认的是MNI_152_T1_2mm_brain，它的分辨率为2x2x2mm。当我们创建一个mask时，它的分辨率将与它所覆盖的模板相同。当我们从mask中提取数据时，数据和mask需要有相同的分辨率。为了避免因图像分辨率不同而导致的任何错误，请使用与我们用于归一化数据的相同模板来创建mask。
使用结构像掩膜抽取数据 一旦创建了掩膜，我们就可以从中提取每个受试者的对比度估计值（contrast estimates）。虽然你可能认为我们会提取第三级分析的结果，但实际上我们想要的是第二级分析的结果；第三级分析是一个单一的图像，每个体素都有一个数字，而在ROI分析中，我们的目标是单独提取每个受试者的对比度估计。
以Incongruent-Congruent对比度估计为例，我们可以在Flanker_2ndLevel.gfeat/cope3.feat/stats目录下找到每个受试者的数据图(data maps)。这些数据图有几种不同的计算方式，包括t统计图、cope图和方差图。我更倾向于从z-统计图中提取数据，因为这些数据已经被转换为正态分布的形式，在我看来，更容易绘制和解释。
为了使我们的ROI分析更容易，我们将把所有的z-统计图合并成一个数据集。为了做到这一点，我们将使用FSL命令和Unix命令的组合。导航到Flanker_2ndLevel.gfeat/cope3.feat/stats目录，然后输入以下内容：
fslmerge -t allZstats.nii.gz `ls zstat* | sort -V` 这将沿着时间维度（用-t选项指定）把所有的Z-statistic图像合并成一个数据集；这只是意味着把各volume数据串联起来，成为一个更大的数据集。第一个参数是输出数据集的名称（allZstats.nii.gz），后面的代码使用星号通配符列出每个以 &amp;ldquo;zstat&amp;quot;开头的文件，然后用-V选项从小到大对它们进行数字排序。
将allZstats.nii.gz文件上移三层，使其位于Flanker主目录中（即输入mv allZstats.nii.gz .../../...）。然后使用fslmeants命令从PCG掩码中提取数据：
fslmeants -i allZstats.nii.gz -m PCG.nii.gz 这将打印26个数字，每个被试一个。每个数字是该被试的对比度估计值，是mask中所有体素的平均数。 这个命令输出的每个数字都对应于进入分析的对比度估计值。例如，第一个数字对应的是sub-01的Incongruent-Congruent的平均对比度估计值，第二个数字是sub-02的平均对比度估计值，以此类推。这些数字可以复制并粘贴到你选择的统计软件包（如R）中，然后你可以对它们进行t检验。 使用球体抽取数据 我们可能已经注意到，使用解剖学掩膜的ROI分析结果并不显著。这可能是因为PCG掩膜覆盖了一个非常大的区域；虽然PCG被标记为一个单一的解剖区域，但我们可能是从几个不同的功能区域提取数据。因此，这可能不是最好的ROI方法。
另一种技术被称为球形ROI方法（spherical ROI）。在这种情况下，一个给定直径的球体以指定的X、Y和Z坐标的三组为中心。这些坐标通常是基于另一项研究的峰值激活，该研究使用与我们所使用的相同或相似的实验设计。这被认为是一个独立的分析，因为ROI的定义是基于一个单独的研究。
下面的动画显示了解剖学和球形ROI的区别： 为了创建这个ROI，我们需要从另一项研究中找到峰值坐标；让我们随机挑选一篇论文，如Jahn等人，2016。在结果部分，我们发现Stroop任务存在冲突效应&amp;ndash;这是一个不同但相关的实验设计，也是为了挖掘认知控制&amp;ndash;在MNI坐标0、20、40处有一个峰值t统计。
接下来的几个步骤很复杂，所以要密切注意每一个步骤：
打开fsleyes，并加载一个MNI模板。在Location窗口的&amp;quot;Coordinates:MNI152&amp;quot;&amp;ldquo;下的字段中，输入0 20 44。就在这些字段的右边，注意体素位置下的字段中的数字的相应变化。在这种情况下，它们是45 73 58。写下这些数字。</description>
    </item>
    
    <item>
      <title>MRtrix3教程 #4 大脑组织边界</title>
      <link>https://LiaoPan.github.io/mrtrix/tissue_boundary/</link>
      <pubDate>Thu, 25 May 2023 18:39:14 +0800</pubDate>
      
      <guid>https://LiaoPan.github.io/mrtrix/tissue_boundary/</guid>
      <description>简介 转换结构像数据 配准扩散图像和解剖图像 参考资料 简介 我们几乎已经准备好开始我们的纤维束流线分析(streamline analysis)，我们将在灰质和白质边界的随机位置放置种子（seeds）。一条流线将从每个种子生长出来，并从该种子区域追踪路径，直到它在另一个区域终止。一些流线会在一些没有意义的地方终止&amp;ndash;例如，流线可能终止于脑室的边界。我们将剔除这些 &amp;ldquo;错误 &amp;ldquo;的流线，剩下的大部分流线似乎是连接遥远的灰质区域。
要做到这一点，我们首先需要在灰质和白质之间建立一个边界。MRtrix命令5ttgen(5tt就是表示生成了5种类型的组织，five-tissue-type)将使用FSL的FAST，连同其他命令，将解剖图像分割成五种组织类型(注意顺序)：
灰质(Grey Matter, GM)； 白质(White Matter, WM)； 脑脊液(Cerebrospinal Fluid, CSF)； 皮质下灰质（如杏仁核和基底神经节）(Subcortical Grey Matter,such as amygdala and basal ganglia)； 病理组织(Pathological Tissue)。 一旦我们将大脑分割成这些组织类别，我们就可以使用边界作为掩码来限制我们放置种子的位置。
转换结构像数据 我们使用mrconvert命令将结构像转换为MRtrix格式。如果你在dwi目录下，你可以输入以下命令：
# 备注：..表示当前目录下的上一层目录 $ mrconvert ../anat/sub-CON02_ses-preop_T1w.nii.gz T1.mif mrconvert: [100%] uncompressing image &amp;#34;sub-CON02_ses-preop_T1w.nii.gz&amp;#34; mrconvert: [100%] copying from &amp;#34;sub-CON02_ses-preop_T1w.nii.gz&amp;#34; to &amp;#34;T1.mif&amp;#34; 之后，我们现在将使用命令5ttgen将解剖图像分割成上面列出的组织类型：
$ 5ttgen -h MRtrix 3.0.4 5ttgen 5ttgen: part of the MRtrix3 package SYNOPSIS Generate a 5TT image suitable for ACT USAGE 5ttgen algorithm [ options ] .</description>
    </item>
    
    <item>
      <title>FSL系列教程 #5. FSL脚本编写</title>
      <link>https://LiaoPan.github.io/fsl/scripts/</link>
      <pubDate>Mon, 03 Jul 2023 10:56:47 +0800</pubDate>
      
      <guid>https://LiaoPan.github.io/fsl/scripts/</guid>
      <description>简介 在对单个受试者的单次run进行预处理并建立模型之后，我们就需要对数据集中所有受试者的所有run进行相同的处理。这看似繁琐，但也是可行的&amp;ndash;我们只有26个受试者，每个受试者有两次run。我们可能认为这可以在一周左右的时间内完成；而且也可以随时将这项任务分配给几名研究助理。
然而，在某些时候，您会遇到两个问题：
我们会发现，手动分析每次运行不仅乏味，而且容易出错，随着要分析的运行数量增加，出错的概率也会显著增加； 对于较大的数据集（例如，80个受试者，每个受试者有5次run），这种方法很快就会变得不切实际。 另一种方法是编写分析脚本。就像演员有一个脚本，告诉他说什么、站在哪里、在哪里移动一样，我们也可以编写一个脚本，告诉计算机如何分析数据集。这样做有双重好处，既可以实现分析自动化，又可以分析任何规模的数据集&amp;ndash;分析两个受试者或两百个受试者的代码几乎完全相同。
首先，我们将创建一个模板，其中包含分析单次run所需的代码，然后我们将使用for-loop自动分析所有运行。这个想法很简单；尽管代码一开始可能难以理解，但一旦我们对其更加熟悉，我们就会发现如何将其应用于任何数据集。
理解下述代码脚本需要Linux的shell脚本基础，推荐掌握了基础的shell脚本语法后，再来继续阅读下述内容。
创建脚本模版 当分析sub-08被试的第一个run时，会创建一个名为run1.feat的目录。在该目录下有几个文件和子目录。其中一个文件design.fsf包含了从FEAT图形用户界面转录到文本文件中的所有代码。这是FSL运行来完成每个预处理和建模步骤的代码。如果在文本编辑器中打开design.fsff文件和用来创建design.fsf文件的FEAT图形用户界面并排比较，我们可以看到输入到FEAT图形用户界面的数据在哪里被写入design.fsf文件。
如果我们打开了FEAT图形用户界面，点击屏幕底部的Load按钮，并选择run1.feat目录下的design.fsf文件，它将把所有设置更改为您保存脚本时在图形用户界面中输入的设置。
在前面的教程中，我们分别运行了FEAT的预处理和模型拟合。现在我们将从FEAT GUI的下拉菜单中选择 &amp;ldquo;Full Analysis（全分析）&amp;quot;，创建一个将这两个步骤结合在一起的模板。
首先，输入rm -r run1.feat删除当前run1.feat目录。然后在命令行输入Feat_gui打开FEAT图形用户界面。我们将在下拉菜单中选择 &amp;ldquo;Full Analysis（全面分析）&amp;ldquo;选项，而不是将其作为两个单独的会话来运行。以前面的教程为指导，填写预处理和模型拟合的所有必填项。
填写完所有字段后，不要点击Go按钮，而是点击Save并标注文件为design_run1。这将保存多个扩展名为 &amp;ldquo;con&amp;rdquo;、&amp;ldquo;mat &amp;ldquo;和 &amp;ldquo;png &amp;ldquo;的文件，但我们的脚本将使用文件design_run1.fsf。
现在对run 2执行相同的步骤，加载相应的功能数据和时序文件。将文件保存为design_run2.fsf。
在代码编辑器(或者文本编辑器)中打开design_run1.fsf，查看所有已填写的选项。我们的目标是使该模板可用于任何被试，只需在for-loop中稍作改动即可。在本例中，我们唯一需要更改的是被试名称，其余选项对每个被试都是相同的。
运行脚本 将design_run1.fsf和design_run2.fsf文件移到包含被试的目录下（即mv design*.fsf ..，然后cd ..）。然后下载脚本 run_1stLevel_Analysis.sh(如下述代码所示)，并将其移动到Flanker目录中：
run_1stLevel_Analysis.sh #!/bin/bash # Generate the subject list to make modifying this script # to run just a subset of subjects easier. # 依次遍历26个被试数据 for id in `seq -w 1 26` ; do subj=&amp;#34;sub-$id&amp;#34; echo &amp;#34;===&amp;gt; Starting processing of $subj&amp;#34; echo cd $subj # 颅骨去除 # If the brain mask doesn’t exist, create it if [ !</description>
    </item>
    
    <item>
      <title>MRtrix3教程 #6 Connectome</title>
      <link>https://LiaoPan.github.io/mrtrix/connectome/</link>
      <pubDate>Wed, 31 May 2023 11:15:56 +0800</pubDate>
      
      <guid>https://LiaoPan.github.io/mrtrix/connectome/</guid>
      <description>简介 创建脑连接组（Connectome） 可视化脑连接组 参考 简介 现在我们已经创建了一个流线图，我们就可以创建一个连接组，代表连接大脑不同部分的流线数量。为了做到这一点，我们必须首先将大脑分割成不同的区域，或节点。做到这一点的一个方法是是使用脑图谱（atlas），将大脑中的每个体素分配给特定的ROI。
你可以使用你想要的任何脑图谱，但在本教程中，我们将使用FreeSurfer附带的脑图谱。因此，我们的第一步将是通过recon-all来处理被试的解剖图像。
# 如果想更换数据生成的目录，可以设置SUBJECTS_DIR环境变量到自己想要的目录路径 $ export SUBJECTS_DIR=&amp;lt;your_custom_path&amp;gt; # 耗时很长，需要慢慢等。 $ recon-all -i sub-CON02_ses-preop_T1w.nii.gz -s sub-CON02_recon -all 创建脑连接组（Connectome） 当recon-al完成后，我们将需要把FreeSurfer解析的标签转换为MRtrix能理解的格式。labelconvert命令将使用FreeSurfer的注解（parcellation）和分割输出来创建一个新的.mif格式的注解（parcellation）文件：
$ labelconvert -help MRtrix 3.0.4 labelconvert Dec 14 2022 labelconvert: part of the MRtrix3 package SYNOPSIS Convert a connectome node image from one lookup table to another USAGE labelconvert [ options ] path_in lut_in lut_out image_out path_in the input image lut_in the connectome lookup table corresponding to the input image lut_out the target connectome lookup table for the output image image_out the output image $ labelconvert sub-CON02_recon/mri/aparc+aseg.</description>
    </item>
    
    <item>
      <title>FreeSurfer教程 #N. 实践教程之CookBook</title>
      <link>https://LiaoPan.github.io/freesurfer/practice/</link>
      <pubDate>Fri, 03 Feb 2023 10:44:45 +0800</pubDate>
      
      <guid>https://LiaoPan.github.io/freesurfer/practice/</guid>
      <description>实践#1:如何将一个个体subject映射到fsaverage？ 实践2:如何提取stats文件夹内的统计信息？ 实践#3:如何提取感兴趣ROI区域的结构信息？ 实践#4:如果构建一个surface ROI重采样到体积（Volume）？ 实践#5:如何使用FreeSurfer去除颅骨(skull-stripping)? 实践#1:如何将一个个体subject映射到fsaverage？ 如何按自定义模板，重建皮层，并提取皮层信息？
实践2:如何提取stats文件夹内的统计信息？ 方法: 使用asegstats2table和aparcstats2table命令来提取 $ asegstats2table --subject &amp;lt;&amp;gt; --common-segs --meas &amp;lt;volume,mean,std&amp;gt; --stats=&amp;lt;stats file&amp;gt; --table=&amp;lt;extracted measurement to a text file&amp;gt; $ asegstats2table --subjects sub-101 sub-103 --common-segs --meas volume --stats=aseg.stats --table=segstats.txt --subjects选项指定了一个被试名称的列表。 --common-segs表示输出所有被试共有的分段，换句话说，如果一个受试者的分段数与其他受试者不同，不要以错误退出命令。 --meas表示要从表中提取哪种结构测量值（&amp;ldquo;volume &amp;ldquo;是默认值；替代值是 &amp;ldquo;mean &amp;ldquo;和 &amp;ldquo;std&amp;rdquo;）。 --stats指的是将从分段数据中提取的统计文件； --table将提取的测量数据写入一个文本文件，按被试名称组织。
同理，aparcstats2table也类似，
$ aparcstats2table --subjects sub-101 sub-103 --hemi lh --meas thickness --parc=aparc --tablefile=aparc.txt --hemi,指定要分析的半球 --meas,要提取的测量值,选项有&amp;quot;thickness&amp;rdquo;, &amp;ldquo;volume&amp;rdquo;, &amp;ldquo;area&amp;rdquo;, &amp;ldquo;meancurv&amp;rdquo; --parc,指定图谱，选项有Desikan-Killinay图谱(&amp;ldquo;aparc&amp;rdquo;)和Destrieux图谱(&amp;ldquo;aparc.a2009s&amp;rdquo;)
实践#3:如何提取感兴趣ROI区域的结构信息？ 如何将一个Volumetric ROI重采样到表面，然后从该ROI中提取结构测量值。 如何将ROI区域映射到皮层上 shell #!/bin/tcsh setenv SUBJECTS_DIR `pwd` # 使用AFNI的3dUndump创建5mm的ROI球体;ROI_file.</description>
    </item>
    
  </channel>
</rss>
